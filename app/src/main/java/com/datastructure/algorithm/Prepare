- 2 medium problem
- Environment, no intelliSense
- Set timer for 20min/question
- Communicate, say assumptions, problem solving, don't be quite

Android theory

    val nodeMap = mutableMapOf<Int, Int>()
    val sumCount = 0

    //if root is null return
    //check if node is on another level of the tree and reset the count and next map data
    //recurse left of tree and recurse right of tree to further get the nodes and
    //add them to the map


    //Binary Tree, Splay Tree, AVL Tree, Binary Search Tree, Red black tree, Treap, HashSets, HashTables
    //Trie, LRU Cache, Heap, Hashing, Matrix

    //Insertion Sort, Quick Sort, Merge Sort

    //Dynamic Programming, Bit Manipulation

    //Time Complexity

    //Topcoder.com, Codeshop.com

    // Cracking the coding interview book
    
    Coding, Behavioral Questions (Leadership principles), System Designs

    // 0 [5]
    // 1 [10, 15]
    // 2 [20, 20]

    fun show(){

       val tree = createTree()
       traverse(tree, 0)

       print(nodeMap.keys)

       print(nodeMap.values)

       nodeMap.values.forEach{
         print(it.sum())
       }

    }

    fun traverse(root : BFSNode, height : Int){

        if (root == null) return root

        if (height == root.size){
            nodeMap[height] = mutableListOf()
        }

        nodeMap[height].add(root.data)

        traverse(root.left, height +1)
        traverse(root.right, height + 1)

    }


    class BFSNode{

     val queue : Queue<BFSNode> = LinkedList<BFSNode>

      data class BFSNode(
            val data : Int,
            val left : BFSNode? = null,
            val right : BFSNode? = null
        )

       fun createTree() : BFSNode {
        val a  = BFSNode(5)
        val b  = BFSNode(4)
        val c  = BFSNode(1)
        val d  = BFSNode(2)

        a.left = b
        a.right = c

        b.left = d

        return a

       }

       //  a
       // b c
       //     d
       //
       //

       fun traverseTree(node : BFSNode?){

        if (node == null) return

        queue.add(node)

        while(queue.isNotEmpty()){

          queue.remove()?.also{

            print("${it.data} ")

                if (it.left != null){
                    queue.add(it.left)
                }

                if (it.right != null){
                   queue.add(it.right)
                }

           }
        }

        queue.add(node)

        print("{node.data} ")

        queue.remove()

        traverse(bfsNode.left)
        traverse(bfsNode.right)

       }

    }

    fun sumTraverse(node : BFSNode, height : Int){

        if (node.data == null) return

        if (height == nodeMap.size){
            nodeMap[height] = listOf()
        }

        nodeMap[height].add(node.data)

        sumTraverse(node.left, height+1)
        sumTraverse(node.right, height+1)

    }
